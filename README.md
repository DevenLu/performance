# Performance

这是一个性能检测库，可以检测

- [x] ANR
- [x] FPS
- [x] 线程和线程池的监控
- [x] IPC(进程间通讯)
- [x] 主线程耗时任务检测

## 检测 ANR 的原理

主要参考了 ANR-WatchDog 的思路，利用一个线程，先向主线程投放一个 msg 。然后 sleep 指定的时间，时间到了之后，检测这个 msg 是否被处理过，入股被处理过，说明这段时间内没有阻塞。如果这个 msg 没有被处理，那么说明这段时间内有阻塞，可能发生了 ANR 。如果发生了 ANR 可以把主线程的调用栈打印出来，作为一个 ANR 问题的 log 信息参考。

检测完后，这个线程继续投放下一个 msg ，然后重复做之前的检测。这样就可以监控 ANR 是否发生了。

但是这个检测有个问题，就是打印的堆栈不一定是指定的时间段内最耗时的堆栈，这个时候，可以考虑缩短检测时间段，多次采样来提高准确率。

## 检测 FPS 的原理

FPS 检测的原理，利用了Android 的屏幕绘制原理。

这里简单说下Android 的屏幕绘制原理。系统每隔 16 ms 就会发送一个 vsync 信号，告诉应用，该开始准备绘制画面了，如果准备顺利，16 ms 后，这个准备好的画面就会被显示出来，如果没准备好，可能就需要 32 ms 后或者更久的时间后，这个画面才能显示出来，这种情况下就发生了丢帧。

检测 FPS 的原理其实挺简单的，就是通过一段时间内，比如 1s，统计绘制了多少个画面，就可以计算出 FPS 。统计的原理也很简单，

## 线程和线程池的监控的原理

线程和线程池的监控，是通过 ‘hook 线程和线程池的构造等一系列方法实现的。在这些 hook 的方法里面做一些事情，比如打印当前堆栈等，就可以知道创建线程和线程池的地方和是谁调用的。然后就可以根据具体的业务和代码来做优化。比如不轻易创线程，全局共用一个线程池等。

## 检测 IPC(进程间通讯)的原理

这个的话，需要对 Binder 进程间通讯机制有教深入的理解。其实原理也不复杂，就是找到所有 IPC 方法调用链的共同点，然后 hook 这个点，在这个点里面打印当前的方法调用栈，这样就可以知道什么时候，什么代码做了 IPC 。 

## 主线程耗时任务检测的原理

这个的话，和 ANR 检测有点相关，都是用到了 Handler ，主线程如果耗时了，就会导致界面卡顿。AndroidPerformanceMonitor(BlockCanary) 虽然能检测到哪些任务耗时，但是无法检测到时谁，在哪里往主线程放了这个耗时的任务。

通过对 Handler 的分析发现，往主线程放入耗时操作，一定会调用 Handler.sendMessageAtTime 方法，如果我们在这个方法里面记录调用堆栈，然后在 Handler.dispatchMessage 方法里面统计耗时，超过阈值的任务，打印之前记录的放入这个 msg 的调用堆栈，我们就可以知道是谁在哪里往主线程里面放入了这个耗时的任务。